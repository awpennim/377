I commented my code pretty thoroughly, so I'll keep this section short. I knew that this is a non-trivial lab, so I was sure to keep methods and classes relatively small. I stored the semaphores and the buffer in the Reducer class, so that when Mappers wanted to add to the buffer, they would have to access the semaphors and buffer through the reducer. This is because the number of Reducers has a 1:1 relationship with the number of semaphore sets and buffers. I used many ConcurrentHashMaps so that the various Reducer threads adding to the central inverted index wouldnt have any thread-safety issues. I abstacted out the printing of the inverted index to its own class so that the code inside the Index class would focus on its job (not printing). I use an AtomicInteger for the total number of remaining reducer threads, since it is a value modified by all Reducer threads. The last design choice I made and feel needs an explanation is how I handled InterruptedExceptions while acquiring the semaphores. Basically, if an InteruptedException happens while acquiring a semaphore, we undo what we've started, and recursively call the method again.

The general idea of how I handled the buffer synchronization, is that when adding to the buffer, we first block until the buffer has an empty space, then we block until we have a lock on modifying the buffer. We add the object to the buffer, then release the lock on modifiying the buffer before telling the "empty" semaphore that we've added an object to the buffer. When removing form the buffer, we first block until the buffer is not empty, then we block until we have a lock on modifying the buffer. We remove the next object form the buffer, then release the lock on modifying the buffer before telling the "full" semaphore that a space has opened up in the buffer.

